/*
Copyright (C) 2015 Runtime Revolution Ltd.

This file is part of LiveCode.

LiveCode is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License v3 as published by the Free
Software Foundation.

LiveCode is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with LiveCode.  If not see <http://www.gnu.org/licenses/>.  */

/*
A widget to display array data in a tree view

Name: arrayData
Type: property
Syntax: set the arrayData of <widget> to <pArray>
Syntax: get the arrayData of <widget>
Summary: The array being displayed by the widget

Parameters:
pArray (array): The array data.

Description:
The arrayData is the data currently being displayed by the tree view widget.

Name: alternateRowBackgrounds

Type: property
Syntax: set the alternateRowBackgrounds of <widget> to (true|false)
Syntax: get the alternateRowBackgrounds of <widget>

Summary: Whether the alternate rows of the widget have different backgrounds or not. 

Description:
Use the alternateRowBackgrounds property if you want to more clearly distinguish the rows displayed by the widget.

Name: selectedElement
Type: property
Syntax: set the selectedElement of <widget> to <pPath>
Syntax: get the selectedElement of <widget>

Summary: Select the row corresponding to <pPath>

Parameters:
pPath: A comma delimited list of array keys.

Description:
<pPath> is a list of the keys which determine the row to be selected. For example, if tArray is the arrayData 
of the widget, to select a row corresponding to tArray["key1"]["subkey2"]["subsubkey5"], simply execute


``` set the selectedElement of widget "Array Viewer" to "key1,subkey2,subsubkey5" ```

Name: showFrameBorder
Type: property
Syntax: set the showFrameBorder of <widget> to {true|false}
Syntax: get the showFrameBorder of <widget>

Summary: Whether the widget has a border or not. 

Description:
Use the showFrameBorder property to show the bounds of the widget object.

Name: selectedElementChanged
Type: message
Syntax: selectedElementChanged pPath

Summary: Sent when an element is selected

Parameters:
pPath: The path to the selected element

Description:
The selectedElementChanged message is sent to the widget's script object when a row of the widget's display is clicked on,
causing that row to be selected. The <pPath> parameter contains the path to the new <selectedElement>.

References: selectedElement (property)

*/

widget com.livecode.widget.treeView

use com.livecode.canvas
use com.livecode.widget
use com.livecode.engine

metadata author is "LiveCode"
metadata version is "1.0.0"
metadata title is "Tree View"

-- property declarations
property arrayData 					get getArrayData 				set setArrayData
property alternateRowBackgrounds 	get mAlternateRowBackgrounds 	set setRowBackgrounds
property selectedElement			get getSelectedElement			set setSelectedElement
property showFrameBorder			get mFrameBorder				set setFrameBorder

// The unmodified array data
private variable mData as Array
// A flat list representing the array items to be displayed
private variable mDataList as List
// The number of lines to be displayed
private variable mDataCount as Integer
// The total height of the displayed data
private variable mDataHeight as Real
// The height of each row
private variable mRowHeight as Real

// The height of the view area
private variable mViewHeight as Real
// The width of the view area
private variable mViewWidth as Real

// The first part of the data being displayed
private variable mViewTopPosition as Real
// The index in the display list corresponding the the top of the view
private variable mFirstDataItem as Integer


private variable mMargin as Real
private variable mRecalculate as Boolean
private variable mAlternateRowBackgrounds as Boolean
private variable mIndentPixels as Integer
private variable mHoverRow as Integer
private variable mFrameBorder as Boolean

private variable mSelectedElement as optional List
private variable mFoldState as Array

private variable mArrowWidth as optional Real
private variable mFoldedArrowPath as Path
private variable mUnfoldedArrowPath as Path

--------------------------------------------------------------------------------
--
--		Message handlers
--
--------------------------------------------------------------------------------

public handler OnCreate() returns nothing
	put path "M0,7.421V0.21c0-0.168,0.188-0.268,0.327-0.174l5.351,3.605c0.124,0.083,0.124,0.265,0,0.348L0.327,7.595 C0.188,7.689,0,7.589,0,7.421z" into mFoldedArrowPath

	put path "M0.221,0l7.565,0c0.177,0,0.281,0.188,0.183,0.327L4.186,5.679c-0.087,0.124-0.278,0.124-0.366,0L0.038,0.327 C-0.061,0.188,0.044,0,0.221,0z" into mUnfoldedArrowPath

	put true into mRecalculate
	put 21 into mRowHeight
	put true into mAlternateRowBackgrounds
	put 6 into mMargin
	put 15 into mIndentPixels
	
	put the empty array into mData
	put the empty list into mDataList
	put the empty array into mFoldState
	
	put my height into mViewHeight
	put my width into mViewWidth
	
	put 0 into mHoverRow
	put 0 into mViewTopPosition
	put true into mFrameBorder
	
	initialiseScrollbar()
end handler

public handler OnSave(out rProperties as Array)
	put the empty array into rProperties
	put mData into rProperties["array"]
	return rProperties
end handler

public handler OnLoad(in pProperties as Array)
	put pProperties["array"] into mData
end handler

public handler OnPaint() returns nothing

	// If anything has changed requiring a recalculation, update parameters
	if mRecalculate then
		updateParameters()
	end if

	variable tTop as Real
	variable tPath as Path
	
	put 0 into tTop
	
	variable tDataItem as Array
	put the empty array into tDataItem
	
	variable tX as Integer
	put 1 into tX
	
	variable tTopOffset
	put mViewTopPosition mod mRowHeight into tTopOffset
	subtract tTopOffset from tTop	

	// Iterate from the first data item drawing each row until the can't display any more items
	repeat with tX from mFirstDataItem up to the number of elements in mDataList
		paintDataItem(element tX of mDataList, tTop, tX)		
		if tTop > mViewHeight then
			exit repeat
		end if
		add mRowHeight to tTop
	end repeat
    
    // Paint the scrollbar
	paintScrollbar(this canvas, getPaint("scrollbar", "fill"))
	
	// Draw the frame
	if mFrameBorder is true then
		put rectangle path of rectangle [0.5,0.5,mViewWidth-0.5,mViewHeight-0.5] into tPath
		set the paint of this canvas to getPaint("frame","stroke")
		stroke tPath on this canvas
	end if
end handler

// Utility for painting a row with top pTop
private handler paintDataItem(in pDataItem as Array, in pTop as Real, in pRow as Integer)
	// Apply any style to this data item
	variable tStyle as String
	put "" into tStyle
	if pDataItem["selected"] is true then 
		put "_selected" after tStyle
	end if
		
	if pRow is mHoverRow then
		put "_hover" after tStyle
	end if	
		
	variable tPath as Path	
	// Draw the alternating row backgrounds if applicable
	if mAlternateRowBackgrounds is true then
		put rectangle path of rectangle [0,pTop,mViewWidth,pTop+mRowHeight] into tPath
		if pRow mod 2 is 1 then
			set the paint of this canvas to getPaint("row","fill" & tStyle)
		else
			set the paint of this canvas to getPaint("row","fill_alternate" & tStyle)
		end if	
		fill tPath on this canvas
	end if
		
	variable tLeft as Real
	put mMargin + (pDataItem["indent"] * mIndentPixels) into tLeft
		
	// Draw the fold/unfold arrow if applicable
	if not pDataItem["leaf"] then
		if pDataItem["folded"] is true then
			put mFoldedArrowPath into tPath
		else
			put mUnfoldedArrowPath into tPath	
		end if
		
		translate tPath by [tLeft,pTop+(mRowHeight/2)-((the height of the bounding box of tPath)/2)]
		set the paint of this canvas to getPaint("text","fill" & tStyle)
		fill tPath on this canvas
	end if
	
	add mArrowWidth + mMargin to tLeft
		
	// Draw the key
	set the paint of this canvas to getPaint("text","disabled" & tStyle)
	fill text "[" & pDataItem["key"] & "]" at left of rectangle [tLeft,pTop,mViewWidth-mMargin-15,pTop+mRowHeight] on this canvas
		
	// Check the key rect cache
	variable tTextBounds as Rectangle
	if "keyRect" is not among the keys of pDataItem then
		measure "[" & pDataItem["key"] & "]" on this canvas
		put the result into tTextBounds
		put tTextBounds into pDataItem["keyRect"]
	else
		put pDataItem["keyRect"] into tTextBounds
	end if

	add the width of tTextBounds + mMargin to tLeft
		
	// Draw the value if it is a 'leaf' (i.e. if it does not contain a sub-array
	if pDataItem["leaf"] then
		set the paint of this canvas to getPaint("text","fill" & tStyle)
		fill text pDataItem["string_value"] at left of rectangle [tLeft,pTop,mViewWidth-mMargin-15,pTop+mRowHeight] on this canvas
	end if
end handler

public handler OnMouseDown() returns nothing
	// Notify the scrollbar of a mouse down
	checkScrollbarMouseDown()
end handler

public handler OnMouseMove() returns nothing			
	if scrollDragging() then
		variable tScrollPositionRatio as Real
		scrollbarDrag(mViewHeight)
		put scrollRatio(mViewHeight) into tScrollPositionRatio
	
		// Calculate the new top position of list
		put the trunc of (mDataHeight - mViewHeight) * tScrollPositionRatio into mViewTopPosition
	
		ensureViewTopPosition()
		updateFirstDataItem()
		updateScrollbar(mViewWidth, mViewHeight, mDataHeight, mViewTopPosition)
		redraw all
	else
		variable tNewHoverRow
		put yPosToRowNumber(the y of the mouse position) into tNewHoverRow
		if mHoverRow is not tNewHoverRow then
			put tNewHoverRow into mHoverRow
			redraw all
		end if
	end if
end handler

public handler onMouseLeave() returns nothing
	put 0 into mHoverRow
	redraw all
end handler

public handler OnMouseUp() returns nothing
	scrollbarMouseUp()
end handler

public handler OnMouseCancel() returns nothing
	scrollbarMouseUp()
end handler

public handler OnMouseScroll(in pDeltaX as Real, in pDeltaY as Real) returns nothing
	if mViewHeight < mDataHeight then
		variable tOldTop as Real
		put mViewTopPosition into tOldTop
	
		if pDeltaY < 0 then
			subtract mRowHeight from mViewTopPosition
		else
			add mRowHeight to mViewTopPosition
		end if
	
		ensureViewTopPosition()
		
		// If nothing changed, don't update anything
		if mViewTopPosition is tOldTop then
			return
		end if
		
		updateFirstDataItem()
		updateScrollbar(mViewWidth, mViewHeight, mDataHeight, mViewTopPosition)
		
		redraw all
    end if
end handler

public handler OnClick() returns nothing
	variable tRowNumber
	put yPosToRowNumber(the y of the click position) into tRowNumber
	
	// Just return if the click was below all the data
	if tRowNumber > the number of elements in mDataList then
		return
	end if
	
	variable tData as Array
	put the empty array into tData
	
	put element tRowNumber of mDataList into tData
	

	if the click count is 1 then
		// Check if the arrow was clicked
		if not tData["leaf"] then
			variable tLeft as Real
			put tData["indent"] * mIndentPixels into tLeft
			
			variable tX as Real
			put the x of the click position into tX
			
			if tX > tLeft and tX < tLeft + mArrowWidth + 2 * mMargin then
				if tData["folded"] is true then
					unfoldPath(tData["path"])
		   		else
					foldPath(tData["path"])
		   		end if
		   		return
		   	end if
		end if
		
		if tData["selected"] is true then
			unselectPath(tData["path"])
		else
			selectPath(tData["path"])
		end if
	end if

	if tData["leaf"] is not true then
	   if the click count > 1 then
		   if tData["folded"] is true then
			   unfoldPath(tData["path"])
		   else
			   foldPath(tData["path"])
		   end if
	   end if
	end if
end handler

private handler yPosToRowNumber(in pYPos as Number) returns Integer
	return the trunc of (pYPos / mRowHeight) + mFirstDataItem
end handler

public handler OnGeometryChanged()
	// Only resizing necessitates a recalculation
	if my height is not mViewHeight or my width is not mViewWidth then
		put true into mRecalculate
	end if
end handler

--------------------------------------------------------------------------------
--
--		Display calculations
--
--------------------------------------------------------------------------------

// Clamp mViewTopPosition
private handler ensureViewTopPosition()
	// Make sure we don't try to scroll above 0
	if mViewTopPosition < 0 then 
		put 0 into mViewTopPosition
	// Make sure we don't try to scroll past the last displayable item
	else if mDataHeight > mViewHeight and mViewTopPosition > mDataHeight - mViewHeight then
		put mDataHeight - mViewHeight into mViewTopPosition
	end if	
end handler

// Calculate mFirstDataItem from the view position
private handler updateFirstDataItem()
	put the floor of (mViewTopPosition / mRowHeight) into mFirstDataItem
	if mFirstDataItem < 1 then
		put 1 into mFirstDataItem
	end if	
end handler

private handler updateParameters() returns nothing
	// Work out the width of the arrow if necessary
	if mArrowWidth is not defined then
		variable tTextBounds as Rectangle
		set the font of this canvas to font getFontName() at size 12
		variable tArrowWidth as Number
		put the width of the bounding box of mFoldedArrowPath into mArrowWidth
	end if

	put the number of elements in mDataList into mDataCount
	put mRowHeight * mDataCount into mDataHeight
	put my height into mViewHeight
	put my width into mViewWidth

	ensureViewTopPosition()
	updateFirstDataItem()
	
	// Calculate scrollbar dimensions
	updateScrollbar(mViewWidth, mViewHeight, mDataHeight, mViewTopPosition)
	
	put false into mRecalculate
end handler

--------------------------------------------------------------------------------
--
--		Utilities for widget display
--
--------------------------------------------------------------------------------

private handler getPaint(pLocation, pType) returns Paint
	if pLocation is "background" then
		if pType is "fill" then
			return solid paint with stringToColor("178,178,178")
		end if
	else if pLocation is "row" then
		if pType is "fill" then
			return solid paint with stringToColor("255,255,255")
		else if pType is "fill_hover" then
			return solid paint with stringToColor("235,235,235")
		else if pType is "fill_selected" then
			return solid paint with stringToColor("10,105,216")
		else if pType is "fill_selected_hover" then
			return solid paint with stringToColor("10,95,193")
		else if pType is "fill_alternate" then
			return solid paint with stringToColor("245,245,245")
		else if pType is "fill_alternate_hover" then
			return solid paint with stringToColor("230,230,230")
		else if pType is "fill_alternate_selected" then
			return solid paint with stringToColor("10,105,216")
		else if pType is "fill_alternate_selected_hover" then
			return solid paint with stringToColor("10,98,200")
		end if
	else if pLocation is "text" then
		if pType is "disabled" then
			return solid paint with stringToColor("0,0,0,150")
		else if pType is "disabled_hover" then
			return solid paint with stringToColor("0,0,0,150")
		else if pType is "disabled_selected" then
			return solid paint with stringToColor("255,255,255,150")
		else if pType is "disabled_selected_hover" then
			return solid paint with stringToColor("255,255,255,150")
		else if pType is "fill" then
			return solid paint with stringToColor("0,0,0")
		else if pType is "fill_hover" then
			return solid paint with stringToColor("0,0,0")
		else if pType is "fill_selected" then
			return solid paint with stringToColor("255,255,255")
		else if pType is "fill_selected_hover" then
			return solid paint with stringToColor("255,255,255")
		else if pType is "fill_alternate" then
			return solid paint with stringToColor("0,0,0")
		else if pType is "fill_alternate_hover" then
			return solid paint with stringToColor("0,0,0")
		else if pType is "fill_alternate_selected" then
			return solid paint with stringToColor("255,255,255")
		else if pType is "fill_alternate_selected_hover" then
			return solid paint with stringToColor("255,255,255")
		end if
	else if pLocation is "scrollbar" then
		if pType is "fill" then
			return solid paint with stringToColor("0,0,0,50")
		end if
	else if pLocation is "frame" then
		if pType is "stroke" then
			return solid paint with stringToColor("188,188,188")
		end if
	end if
	
	return solid paint with stringToColor("255,100,200")
end handler

private handler getFontName() returns String
	return "Helvetica Neue"
	
	return the name of the font of this canvas
end handler

private handler stringToColor(in pString as String) returns Color
	variable tRed as Real
	variable tGreen as Real
	variable tBlue as Real
	variable tAlpha as Real

	variable tComponentList as List
	split pString by "," into tComponentList

	variable tComponentCount
	put the number of elements in tComponentList into tComponentCount
	if tComponentCount is not 3 and tComponentCount is not 4 then
		// Invalid number of components detected
		throw "Invalid color"
	end if

	put (element 1 of tComponentList) parsed as number into tRed
	put (element 2 of tComponentList) parsed as number into tGreen
	put (element 3 of tComponentList) parsed as number into tBlue

	if tComponentCount is 4 then
		put (element 4 of tComponentList) parsed as number into tAlpha
	else
		put 255 into tAlpha
	end if

	return color [ tRed/255, tGreen/255, tBlue/255, tAlpha/255 ]
end handler

--------------------------------------------------------------------------------
--
--		Handlers for data management and array/list conversions
--
--------------------------------------------------------------------------------

// Given a 'path' of array keys as a list, and a value, modify xArray such that
// 	the value of xArray[element 1 of pPath][element 2 of pPath]... is pValue
// 	creating the keys if necessary
private handler setValueOnPath(in pPath as List, in pValue as any, inout xArray as Array)
	if the number of elements in pPath is 1 then
		put pValue into xArray[element 1 of pPath]
	else
		if (element 1 of pPath) is not among the keys of xArray then
			put the empty array into xArray[element 1 of pPath]
		end if
		setValueOnPath(element 2 to -1 of pPath, pValue, xArray[element 1 of pPath])
	end if
end handler

// Return the whole stored array
private handler getArrayData() returns Array
	return mData
end handler

// Convert an array to a list, as used by this widget. Ignoring the 'folded' ans selected
//  parameters, mDataList should always be the result of calling this on mData
private handler convertArrayToList(in pArray as Array, in pLevel as Integer, in pPath as List) returns List

	if pArray is empty then
		return the empty list
	end if

	variable tList as List
	put the empty list into tList
	
	variable tKeys as List
	put the keys of pArray into tKeys
	sort tKeys in ascending order
	
	variable tKey as String
	variable tElement as Array
	
	repeat for each element tKey in tKeys
		put the empty array into tElement
		put tKey into tElement["key"]
		put pLevel into tElement["indent"]
		put false into tElement["selected"]
		
		variable tPath as List
		put pPath into tPath
		push tKey onto tPath
		
		put tPath into tElement["path"]	
		if pArray[tKey] is an array then
			put false into tElement["leaf"]
			put true into tElement["folded"]
			push tElement onto tList
		else
			put true into tElement["leaf"]
			put pArray[tKey] into tElement["value"]
			
			if pArray[tKey] is a string then
				put pArray[tKey] into tElement["string_value"]
			else
				variable tString as optional String
				format pArray[tKey] as string into tString
				if tString is not defined then
					put "Can't display value" into tString
				end if
				put tString into tElement["string_value"]
			end if	

			push tElement onto tList
		end if	
	end repeat
	
	return tList
end handler

// A handler type for passing into 'applyToNode'
handler type NodeApply(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)

// A handler of type NodeApply to pass into 'applyToNode' - unselects the key on the given path
private handler unselectKey(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)
	put false into xList[pListElt]["selected"]
	put undefined into mSelectedElement
end handler

// A handler of type NodeApply to pass into 'applyToNode' - selects the key on the given path
private handler selectKey(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)
	put true into xList[pListElt]["selected"]
	put pPath into mSelectedElement
end handler

// A handler of type NodeApply to pass into 'applyToNode' - removes the key on the given path
private handler removeKey(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)
	delete element pListElt of xList
	delete xArray[element pLevel + 1 of pPath]
end handler

// Update the fold state on the given node, and below
private handler updateFoldState(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, in pArray as Array, in pFold as Boolean)
	// Update the fold state
	variable tPath as List
	put the empty list into tPath
	variable tKey as String
	repeat for each element tKey in pPath
		push tKey onto tPath
		push "array" onto tPath
	end repeat
	put "folded" into element -1 of tPath
	setValueOnPath(tPath, pFold, mFoldState)
	
	variable tArray as Array
	put mFoldState into tArray
	repeat for each element tKey in element 1 to -2 of tPath
		put tArray[tKey] into tArray
	end repeat
	
	applyFoldStateKey(element pLevel + 1 of pPath, pLevel, pListElt - 1, tArray, pArray[element pLevel + 1 of pPath], xList)
end handler

// A handler of type NodeApply to pass into 'applyToNode' - unfolds the array value on the given path
private handler unfoldKey(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)
	updateFoldState(pListElt, pPath, pLevel, xList, xArray, false)
end handler

// A handler of type NodeApply to pass into 'applyToNode' - folds the array value on the given path
private handler foldKey(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)
	updateFoldState(pListElt, pPath, pLevel, xList, xArray, true)
end handler

// Delete the array key on the given path and update the display list
private handler removePath(in pPath as List)
	applyToNode(removeKey, pPath, 0, 0, mDataList, mData)
	redraw all
end handler

// Unfold the key at the target path
private handler unfoldPath(in pPath as List)
	applyToNode(unfoldKey, pPath, 0, 0, mDataList, mData)	
	// Changing fold state makes a recalculation necessary
	put true into mRecalculate	
	redraw all
end handler

// Fold the key at the target path
private handler foldPath(in pPath as List)
	applyToNode(foldKey, pPath, 0, 0, mDataList, mData)	
	// Changing fold state makes a recalculation necessary
	put true into mRecalculate
	redraw all
end handler

// Select the key at the target path
private handler selectPath(in pPath as List)
	// Unselect the existing selection if applicable
	if mSelectedElement is defined and mSelectedElement is not pPath then
		applyToNode(unselectKey, mSelectedElement, 0, 0, mDataList, mData)
	end if

	if mSelectedElement is not defined or mSelectedElement is not pPath then
		applyToNode(selectKey, pPath, 0, 0, mDataList, mData)
		post "selectedElementChanged" to my script object
		redraw all
	end if
end handler

// Unselect the key at the target path
private handler unselectPath(in pPath as List)
	if mSelectedElement is defined and mSelectedElement is pPath then
		applyToNode(unselectKey, pPath, 0, 0, mDataList, mData)
		post "selectedElementChanged" to my script object
		redraw all
	end if
end handler

// Recursive implementation of performing an action to the node at the end of the given path. 
// Acts on a list (in the format used by this widget) and an array simultaneously.
// We are quite lax with checking here, since this will only be used internally 
// 	after a delete action happens, and so the element should exist by definition.
// If the specified path happens not to exist, this does nothing anyway.
private handler applyToNode(in pHandler as NodeApply, in pPathToNode as List, in pLevel as Integer, in pStart as Integer, inout xList as List, inout xArray as Array)
	variable tKey as String
	put element pLevel + 1 of pPathToNode into tKey

	variable tCount as Integer
	variable tElement as Array
	repeat with tCount from pStart + 1 up to the number of elements in xList
		put xList[tCount] into tElement
		if tElement["key"] is tKey and pLevel is tElement["indent"] then
			if the number of elements in pPathToNode is pLevel + 1 then
				pHandler(tCount, pPathToNode, pLevel, xList, xArray)
			else
				applyToNode(pHandler, pPathToNode, pLevel + 1, tCount, xList, xArray[tKey])			
			end if
			exit repeat
		end if	
	end repeat
end handler

// Remove all elements below pStart in the list that have a greater indent
private handler deleteSubElements(in pStart as Integer, in pTopIndent as Integer, inout xList as List)
	variable tLastSubElement as Integer
	variable tFirstSubElement as Integer
	put pStart + 1 into tFirstSubElement
	// Do if there are no more elements in the list, make sure nothing happens
	put pStart into tLastSubElement			
	variable tSubCount
	repeat with tSubCount from tFirstSubElement up to the number of elements in xList
		if xList[tSubCount]["indent"] <= pTopIndent then
			put tSubCount - 1 into tLastSubElement
			exit repeat
		end if
		put tSubCount into tLastSubElement
	end repeat
	if tFirstSubElement <= tLastSubElement then
		delete element tFirstSubElement to tLastSubElement of xList
	end if
end handler

private handler applyFoldStateKey(in pKey as String, in pLevel as Integer, in pStart as Integer, in pFoldState as Array, in pArray as Array, inout xList as List)
	variable tCount as Integer
	variable tElement as Array
	variable tPath as List
	// Find the key
	repeat with tCount from pStart + 1 up to the number of elements in xList
		put xList[tCount] into tElement
		if tElement["key"] is pKey and pLevel is tElement["indent"] then
			// Either splice in the below elements
			if pFoldState["folded"] is false then
				put false into xList[tCount]["folded"] 
			
				splice convertArrayToList(pArray, pLevel + 1, tElement["path"]) after element tCount of xList
		
				// Apply the fold state on the subelements
				if "array" is among the keys of pFoldState then
					applyFoldState(pLevel + 1, tCount, pFoldState["array"], pArray, xList)
				end if
				exit repeat
			// or delete them
			else
				put true into xList[tCount]["folded"] 
				deleteSubElements(tCount, tElement["indent"], xList)
			end if	
			exit repeat
		end if	
	end repeat	
end handler

private handler applyFoldState(in pLevel as Integer, in pStart as Integer, in pFoldState as Array, in pArray as Array, inout xList as List)

	// Find the match for each key at the appropriate level, and set folded accordingly
	variable tKey as String
	repeat for each key tKey in pFoldState
		applyFoldStateKey(tKey, pLevel, pStart, pFoldState[tKey], pArray[tKey], xList)
	end repeat

end handler

// Given a 'path' of array keys as a list, and a value, adjust the mDataList and mData variables
// 	to reflect the action of putting pValue into mData[element 1 of pPath][element 2 of pPath]...
private handler setDataOnPath(in pPath as List) returns nothing
	
	// pPath having 1 element is an error, as that means mData is just a string rather than an array
	if the number of elements in pPath is 1 then
		return
	end if
	
	// The last element of pPath is the actual value, the rest of it is the keys.
	variable tActualPath as List
	put element 1 to -2 of pPath into tActualPath
	
	variable tValue as String
	put element -1 of pPath into tValue
	
	// Simultaneously adjust the backing list and array to reflect the added value.
	setDataListOnPath(tActualPath, tValue, 0, mDataList, mData)

end handler

private handler setRowBackgrounds(in pShowAlternateBackgrounds as Boolean) returns nothing
	put pShowAlternateBackgrounds into mAlternateRowBackgrounds
	redraw all
end handler

// Recursive implementation of setting data on a given path. 
// Acts on a list (in the format used by this widget) and an array simultaneously.
private handler setDataListOnPath(in pPath as List, in pValue as any, in pLevel as Integer, inout xList as List, inout xArray as Array) returns nothing

	variable tElement as Array
	variable tCount as Integer
	variable tNewElement as Array
	put the empty array into tNewElement
	
	repeat with tCount from 1 up to the number of elements in xList
		put element tCount of xList into tElement
		
		// The easy case - just insert the new element
		if tElement["key"] > element pLevel + 1 of pPath then
		
			// update the backing array
			setValueOnPath(element pLevel + 1 to -1 of pPath, pValue, tNewElement)
			put tNewElement[element pLevel + 1 of pPath] into xArray[element pLevel + 1 of pPath] 
			
			// update the list
			splice convertArrayToList(tNewElement, pLevel, pPath) before element tCount of xList
			return
			
		// We already have a key for the start of this path
		else if tElement["key"] is element pLevel + 1 of pPath then
			// The new element replaces the old one if the new one is just a string...
			if the number of elements in pPath is pLevel + 1 then
				put pValue into xArray[element pLevel + 1 of pPath]
				put pValue into tElement["value"]
				
			// ...or if the old one was just as string.
			else if tElement["leaf"] then
				setValueOnPath(element pLevel + 2 to -1 of pPath, pValue, tNewElement)
				put tNewElement into xArray[element pLevel + 1 of pPath]
				splice convertArrayToList(tNewElement, pLevel, pPath) after element tCount of xList 

			// Otherwise, go one step further into the path and set
			else
				setDataListOnPath(pPath, pValue, pLevel + 1, element tCount + 1 to -1 of xList, xArray[element pLevel + 1 of pPath])
			end if
			return
		end if
	end repeat
	
	// If we reached the end of the list then append this to the end
	setValueOnPath(element pLevel + 1 to -1 of pPath, pValue, tNewElement)
	put tNewElement[element pLevel + 1 of pPath] into xArray[element pLevel + 1 of pPath] 
	splice convertArrayToList(tNewElement, pLevel, pPath) after element tCount of xList
end handler

--------------------------------------------------------------------------------
--
--		Properties
--
--------------------------------------------------------------------------------

// Replace the existing data wholesale with a new array pData
private handler setArrayData(in pData as Array) returns nothing
	put pData into mData
	put convertArrayToList(pData, 0, the empty list) into mDataList
	
	// Unfold unfolded before reapplying selection
	if mFoldState is not empty then
		applyFoldState(0, 0, mFoldState, mData, mDataList)
	end if	
		
	// Force reselection of previously selected path (if possible)
	if mSelectedElement is defined then
		applyToNode(selectKey, mSelectedElement, 0, 0, mDataList, mData)
	end if
	put true into mRecalculate
	redraw all
end handler

private handler setFrameBorder(in pFrameBorder as Boolean) returns nothing
	put pFrameBorder into mFrameBorder
	redraw all
end handler

private handler setSelectedElement(in pElement as String)
	variable tPath as List
	split pElement by "," into tPath
	selectPath(tPath)
end handler

private handler getSelectedElement() returns String
	variable tElement as String
	if mSelectedElement is defined then
		combine mSelectedElement with "," into tElement
	else
		put the empty string into tElement
	end if
	return tElement
end handler

--------------------------------------------------------------------------------
--
--		Scrollbar
--		In the future, a scrollbar will be a widget in its own right 
--		and included as a component of scrollable widgets.
--
--------------------------------------------------------------------------------

private variable mScrollbarHeight as Real
private variable mScrollbarPath as Path
private variable mScrollbarY as Real

// Drag related 
private variable mDragging as Boolean
private variable mDragStartLoc as Point
private variable mDragScrollbarOffset as Real

constant kScrollbarWidth is 5

// Will be the scrollbar's OnCreate handler
public handler initialiseScrollbar()
	put 0 into mScrollbarHeight
	put false into mDragging
end handler

// Will be the scrollbar's OnPaint handler
public handler paintScrollbar(in pCanvas as Canvas, in pPaint as Paint)
	// Draw scrollbar if there is any need
	if mScrollbarHeight > 0 then
		set the paint of pCanvas to pPaint
		fill mScrollbarPath on pCanvas	
	end if
end handler

// Will be the scrollbar's OnMouseDown handler
public handler checkScrollbarMouseDown()
	if mScrollbarHeight > 0 then
		put the mouse position into mDragStartLoc
		
		variable tScrollbarRect as Rectangle
		put the bounding box of mScrollbarPath into tScrollbarRect

		if mDragStartLoc is within tScrollbarRect then
			put true into mDragging
			put the y of mDragStartLoc - the top of tScrollbarRect into mDragScrollbarOffset
		end if
	end if
end handler

public handler scrollbarMouseUp()
	put false into mDragging
end handler

private handler scrollbarYFromView(in pViewHeight as Real, in pDataHeight as Real, in pTopPosition as Real) returns Real
	variable tScrollPositionRatio as Real
	put pTopPosition / (pDataHeight - pViewHeight) into tScrollPositionRatio
	return (pViewHeight - mScrollbarHeight) * tScrollPositionRatio
end handler

private handler updateScrollbar(in pViewWidth as Real, in pViewHeight as Real, in pDataHeight as Real, in pTopPosition as Real)

	variable tScrollableHeight as Real
	variable tScrollbarHeight as Real
	variable tScrollbarRatio as Real
	
	put pDataHeight - pViewHeight into tScrollableHeight
	if tScrollableHeight < 0 then
		put 0 into tScrollableHeight
	end if	

	put pViewHeight / pDataHeight into tScrollbarRatio
	
	if tScrollbarRatio >= 1 or tScrollbarRatio <= 0 then 
		put 0 into mScrollbarHeight
	else
		put pViewHeight * tScrollbarRatio into tScrollbarHeight
	
		if tScrollbarHeight < 25 then
			put 25 into mScrollbarHeight
		else
			put tScrollbarHeight into mScrollbarHeight
		end if	
		
		variable tScrollbarY as Real
		put scrollbarYFromView(pViewHeight, pDataHeight, pTopPosition) into tScrollbarY

		variable tRect as Rectangle
		put rectangle [pViewWidth - 10, 0, pViewWidth - 10 + kScrollbarWidth, mScrollbarHeight] into tRect
		put rounded rectangle path of tRect with radius 3 into mScrollbarPath
	
		put 0 into mScrollbarY
		setScrollbarY(tScrollbarY)
	end if	
end handler

private handler setScrollbarY(in pScrollbarY as Real)
	variable tScrollbarMove as Real
	put pScrollbarY - mScrollbarY into tScrollbarMove
	translate mScrollbarPath by [0, tScrollbarMove]
	put pScrollbarY into mScrollbarY
end handler

private handler scrollbarDrag(in pViewHeight as Real)
	// Get the mouse y position
	variable tMouseY as Real
	put the y of the mouse position into tMouseY
		
	if tMouseY < mDragScrollbarOffset then
		put mDragScrollbarOffset into tMouseY
	else if tMouseY > mViewHeight + mDragScrollbarOffset - mScrollbarHeight then
		put mViewHeight + mDragScrollbarOffset - mScrollbarHeight into tMouseY
	end if
		
	// Set the y of the new middle of the scrollbar
	variable tScrollbarY as Real
	put tMouseY - mDragScrollbarOffset into tScrollbarY
	setScrollbarY(tScrollbarY)
end handler

private handler scrollbarY() returns Real
	return mScrollbarY
end handler

private handler scrollDragging() returns Boolean
	return mDragging
end handler

private handler scrollRatio(in pViewHeight as Real)
	// Get the scrollbar space
	variable tScrollbarSpace as Real
	variable tScrollbarSpaceTop as Real
	put pViewHeight - mScrollbarHeight into tScrollbarSpace
	
	return mScrollbarY / tScrollbarSpace
end handler

end widget